### BITを利用して値を動的に追加/削除しながらその中央値を求める
BITは数列のある1点に値を加算することと、範囲和を求めることができるデータ構造です。これを中央値を求めるために使うことができます。

先ほど見たように今回求めたい中央値は小さい方から ⌈k2⌉ 番目の値であり、つまり「 m 以下の要素が ⌈k2⌉ 個存在する」という条件を満たす最小の m ということになります。

つまり値 ai の追加を「BITのインデックス ai に1を加算する」と処理しておけば、中央値は範囲和を用いて二分探索をすることで求めることができます。
(aiの取りうる範囲が大きい時は圧縮するイメージ)

[参照コード](./DynamicMedian.cpp)

### BITを使用して反転数(転倒数)を求める
[解説URL](https://scrapbox.io/pocala-kyopro/%E8%BB%A2%E5%80%92%E6%95%B0)  
[参照コード](./InversionNumber.cpp)
iまで見た時にi以下の数の和をBITを使用して求める
```
ex)
N = 9
A = [7, 2, 5, 4, 1, 3, 0, 8, 6]
BIT = [0, 0, 0, 0, 0, 0, 0, 0, 0]

# i = 0, a0 = 7
BIT = [0, 0, 0, 0, 0, 0, 0, 0, 0]
sum( [0, 7) ) = 0 # i = 0までの7より小さい数

BIT = [0, 0, 0, 0, 0, 0, 0, 1, 0] # BIT更新

...

# i = 5, a5 = 3
BIT = [0, 1, 1, 0, 1, 1, 0, 1, 0]
sum( [0, 3) ) = 2 # i = 5までの3より小さい数
i - sum( [0, 3) ) = 自分より右側つまり転倒数の個数

# このi-sum( [0, ai) )を合計していくことで全体の転倒数がわかる
```
